You define models → Prisma generates SQL → Postgres executes it.

---------------------
How to write Prisma code?

schema.prisma is NOT SQL
It is NOT TypeScript

It’s a schema definition language (DSL) that describes:

Tables → model

Columns → fields

Relations → @relation

Constraints → @id, @unique

Indexes → @@index

Prisma converts this into real SQL for Postgres.

-------------------

Rules:
Rule 1 — Model = Table
model Customer {
}

Rule 2 — Field syntax
fieldName Type Modifiers


Example:

email String @unique


Prisma Type / Postgres Meaning
String => TEXT / VARCHAR
Int	=> INTEGER
Boolean	=> BOOLEAN
DateTime => TIMESTAMP
Decimal	=> DECIMAL


npx prisma studio => to get UI of your database on browser!

Node = JavaScript runtime outside the browser
Why Node exists

Browsers already had:

JS engine (V8)

Event loop

Async I/O

But:

No filesystem access

No sockets

No DB access

Node took V8 and added system APIs:

Files (fs)

Network (http, net)

Processes

Environment variables

So now JS can:

Listen on ports

Talk to databases

Read/write files

That’s why backend JS is possible.

Express — why it exists

Express is a thin abstraction over Node’s HTTP module

It gives you:

Routing

Middleware pipeline

Request/response helpers

Predictable structure

It just organizes HTTP logic.

Think of Express as:

“A traffic controller for requests”

Express mental model:
Every request goes through:
Request
  ↓
Middleware 1
  ↓
Middleware 2
  ↓
Route handler
  ↓
Response

- Middleware can:

Modify request

Block request

Attach data

Log

Authenticate

| Layer      | Responsibility  |
| ---------- | --------------- |
| Node       | Runtime         |
| Express    | HTTP + routing  |
| Prisma     | Data access     |
| PostgreSQL | Source of truth |


Node & Express (In Simple Words):
Node.js  is JavaScript running outside the browser.
It lets you use JavaScript to build servers, tools, and backend logic.
Think of Node as the “engine” that runs your code.

---------------------

Express is a small framework that sits on top of Node.
It makes it easy to build web servers and APIs.
Without Express, doing simple things in Node takes many lines of code.

---------------------

const express = require('express');
You load the Express library into your file.

const app = express();
You create an Express application.

app.get('/', (req, res) => { ... });
You create a route that listens for GET requests.

(req, res) are objects:
req = information coming from the user
res = what you send back to the user

app.listen(3000, () => { ... });
You tell your server to start listening on port 3000.
A port is like a “door” your server uses.

console.log('Server running on port 3000');
Just a message in your terminal so you know it’s working.

What is “middleware”?
Think of middleware as a checkpoint your request passes through before reaching the final route.

When someone visits your server:
Request → middleware → route → response

What is “routing”?
Routing is simply telling your server what to do when someone visits a specific URL.

app.get("/customers/:id/summary", ...)
You are literally saying:
“When an HTTP GET request hits this path, run this function.”

How Node + Express handle a request?

Imagine someone visits:
http://localhost:3000/
Here’s what happens behind the scenes:

1- Node receives the request
2- Express checks if you have middleware → runs it
3- Express checks your routes
4- If a route matches, Express runs your code
5- You send a response
6- Node delivers it back to the browser

It’s like a tiny factory:

-Node is the building
-Express is the conveyor belt
-Middleware is quality control
-Routes are the workers doing specific jobs
-Response is the final product

Typical Express folder structure:
project/
│
├── server.js        ← main file
├── routes/          ← route files
├── controllers/     ← logic for each route
├── middleware/      ← custom middleware
└── public/          ← static files (images, css, js)

------------------------

Route (Express)
   ↓
Service (Business logic)
   ↓
Prisma (DB access)

| Layer   | Question                                     |
| ------- | -------------------------------------------- |
| Route   | How does the request enter/leave the system? |
| Service | What rules decide the result?                |
| Prisma  | How is data stored/fetched?                  |

If an interviewer asks:

“Why not put everything in the route?”

You answer:

“Routes should only handle transport concerns. Business rules belong in services so they’re reusable, testable, and independent of HTTP.”
or
“Routes handle transport concerns like HTTP and request/response. Services encapsulate business logic and rules so they’re reusable, testable, and independent of the delivery mechanism.”

Note:
“Unhandled errors can crash Node, so routes(Express) must catch errors and translate them into HTTP responses. Services and Prisma should only throw domain or technical errors, not HTTP concepts. Because HTTP is a transport concern and Routes are responsible for translating errors into HTTP responses.”

Note:
Whenever you wrap code in a try/catch, JavaScript watches the code inside the try block.
If anything inside the try block fails, JavaScript automatically creates an error object and sends it into the catch.

Notes about 500 error:
500 = “something broke on the server”
It’s not the client’s fault
The server couldn’t complete the request

Notes:
APIs should return structured data, not plain text
JSON is the universal format for APIs

What is Prisma seed script?
"A Prisma seed script is simply a little program you write to fill your database with initial data — usually fake data, test data, or default records your app needs to run."
It’s just a JavaScript or TypeScript file (usually prisma/seed.ts or prisma/seed.js) that uses the Prisma Client to insert data.