You define models → Prisma generates SQL → Postgres executes it.

---------------------
How to write Prisma code?

schema.prisma is NOT SQL
It is NOT TypeScript

It’s a schema definition language (DSL) that describes:

Tables → model

Columns → fields

Relations → @relation

Constraints → @id, @unique

Indexes → @@index

Prisma converts this into real SQL for Postgres.

-------------------

Rules:
Rule 1 — Model = Table
model Customer {
}

Rule 2 — Field syntax
fieldName Type Modifiers


Example:

email String @unique


Prisma Type / Postgres Meaning
String => TEXT / VARCHAR
Int	=> INTEGER
Boolean	=> BOOLEAN
DateTime => TIMESTAMP
Decimal	=> DECIMAL


npx prisma studio => to get UI of your database on browser!

Node = JavaScript runtime outside the browser
Why Node exists

Browsers already had:

JS engine (V8)

Event loop

Async I/O

But:

No filesystem access

No sockets

No DB access

Node took V8 and added system APIs:

Files (fs)

Network (http, net)

Processes

Environment variables

So now JS can:

Listen on ports

Talk to databases

Read/write files

That’s why backend JS is possible.

Express — why it exists

Express is a thin abstraction over Node’s HTTP module

It gives you:

Routing

Middleware pipeline

Request/response helpers

Predictable structure

It just organizes HTTP logic.

Think of Express as:

“A traffic controller for requests”

Express mental model:
Every request goes through:
Request
  ↓
Middleware 1
  ↓
Middleware 2
  ↓
Route handler
  ↓
Response

- Middleware can:

Modify request

Block request

Attach data

Log

Authenticate

| Layer      | Responsibility  |
| ---------- | --------------- |
| Node       | Runtime         |
| Express    | HTTP + routing  |
| Prisma     | Data access     |
| PostgreSQL | Source of truth |


Node & Express (In Simple Words):
Node.js  is JavaScript running outside the browser.
It lets you use JavaScript to build servers, tools, and backend logic.
Think of Node as the “engine” that runs your code.

---------------------

Express is a small framework that sits on top of Node.
It makes it easy to build web servers and APIs.
Without Express, doing simple things in Node takes many lines of code.

---------------------

const express = require('express');
You load the Express library into your file.

const app = express();
You create an Express application.

app.get('/', (req, res) => { ... });
You create a route that listens for GET requests.

(req, res) are objects:
req = information coming from the user
res = what you send back to the user

app.listen(3000, () => { ... });
You tell your server to start listening on port 3000.
A port is like a “door” your server uses.

console.log('Server running on port 3000');
Just a message in your terminal so you know it’s working.

What is “middleware”?
Think of middleware as a checkpoint your request passes through before reaching the final route.

When someone visits your server:
Request → middleware → route → response

What is “routing”?
Routing is simply telling your server what to do when someone visits a specific URL.

app.get("/customers/:id/summary", ...)
You are literally saying:
“When an HTTP GET request hits this path, run this function.”

How Node + Express handle a request?

Imagine someone visits:
http://localhost:3000/
Here’s what happens behind the scenes:

1- Node receives the request
2- Express checks if you have middleware → runs it
3- Express checks your routes
4- If a route matches, Express runs your code
5- You send a response
6- Node delivers it back to the browser

It’s like a tiny factory:

-Node is the building
-Express is the conveyor belt
-Middleware is quality control
-Routes are the workers doing specific jobs
-Response is the final product

Typical Express folder structure:
project/
│
├── server.js        ← main file
├── routes/          ← route files
├── controllers/     ← logic for each route
├── middleware/      ← custom middleware
└── public/          ← static files (images, css, js)

------------------------

Route (Express)
   ↓
Service (Business logic)
   ↓
Prisma (DB access)

| Layer   | Question                                     |
| ------- | -------------------------------------------- |
| Route   | How does the request enter/leave the system? |
| Service | What rules decide the result?                |
| Prisma  | How is data stored/fetched?                  |

If an interviewer asks:

“Why not put everything in the route?”

You answer:

“Routes should only handle transport concerns. Business rules belong in services so they’re reusable, testable, and independent of HTTP.”
or
“Routes handle transport concerns like HTTP and request/response. Services encapsulate business logic and rules so they’re reusable, testable, and independent of the delivery mechanism.”

Note:
“Unhandled errors can crash Node, so routes(Express) must catch errors and translate them into HTTP responses. Services and Prisma should only throw domain or technical errors, not HTTP concepts. Because HTTP is a transport concern and Routes are responsible for translating errors into HTTP responses.”

Note:
Whenever you wrap code in a try/catch, JavaScript watches the code inside the try block.
If anything inside the try block fails, JavaScript automatically creates an error object and sends it into the catch.

Notes about 500 error:
500 = “something broke on the server”
It’s not the client’s fault
The server couldn’t complete the request

Notes:
APIs should return structured data, not plain text
JSON is the universal format for APIs

What is Prisma seed script?
"A Prisma seed script is simply a little program you write to fill your database with initial data — usually fake data, test data, or default records your app needs to run."
It’s just a JavaScript or TypeScript file (usually prisma/seed.ts or prisma/seed.js) that uses the Prisma Client to insert data.

What pagination means?
-Pagination = don’t return everything at once.
Instead of this:
“Give me all transactions ever”

You do this:
“Give me 10 transactions at a time”

Then:
Page 1 → first 10
Page 2 → next 10
Page 3 → next 10

That’s it.

Why pagination exists?

Imagine an account with:
5 transactions → fine
5,000 transactions → slow
5,000,000 transactions → your server dies

Without pagination:
Huge DB load
Huge memory usage
Slow response
Bad UX
Easy DoS vector

Pagination protects your backend.

example:
GET /accounts/123/transactions?page=1&limit=10
[
  { "id": 1, ... },
  { "id": 2, ... },
  ...
  { "id": 10 }
]

GET /accounts/123/transactions?page=2&limit=10
[
  { "id": 11, ... },
  ...
  { "id": 20 }
]
Same endpoint. Different slice of data.

The two key concepts (memorize these)
1️⃣ limit
How many items per page
“Give me 10 transactions”

2️⃣ offset
How many items to skip
“Skip the first 20, then give me 10”

Formula:
offset = (page - 1) × limit
Example:
page = 1 → offset = 0
page = 2 → offset = 10
page = 3 → offset = 20

Where pagination logic belongs?
| Layer       | Responsibility                 |
| ----------- | ------------------------------ |
| **Route**   | Read `page` & `limit` from URL |
| **Service** | Calculate offset & query DB    |
| **DB**      | Return only that slice         |

Note:
“Pagination prevents large unbounded queries.
The route reads page and limit, the service calculates offset,
and the database returns only a slice using skip/take.”

Where pagination starts (route layer)
Pagination parameters always come from the URL, not the body.

So in Express:
req.params → path variables (:id)
req.query → pagination controls

Note:
In Express:
req.query Contains: { page: "2", limit: "5" }
- Query params are strings, so we must convert them.


Who sets page and limit?
The frontend (React app) sets them.

Your backend does not set page and limit.
Your backend reads them.

Think of it like this:
Backend = “I can give you paginated data if you tell me which page you want.”
Frontend = “Okay, I want page 2 with 10 items.”

Why the backend doesn’t set them?
Because pagination is a client-side decision.
The frontend decides:

How many items to show per page
Which page the user is on
When to load the next page

The backend just responds with the correct slice of data.

--------------------------------
Workflow:
Client (Frontend)
   ↓
GET /customers/:id/flags?page=1
   ↓
Controller
   ↓
Service (validation + pagination logic)
   ↓
Prisma
   ↓
Database
--------------------------------
HTTP request
   ↓
Controller (transport layer)
   ↓
Service (business rules)
   ↓
Prisma (data access)
   ↓
PostgreSQL


Note:
What is a controller?
A controller:

-Talks HTTP
-Reads req
-Sends res
-Calls services
-Does NO business logic
If you ever see Prisma inside a controller → ❌ design smell

Note:
“I follow a layered architecture.
Routes map URLs to controllers.
Controllers handle HTTP concerns.
Services contain business logic.
Prisma is the data access layer.”

Note:
Routes decide WHERE the request goes
Controllers decide WHAT to send back
Services decide HOW the business works

- Controller = “HTTP brain”
- Route = “URL wiring”

Note:
Request
→ Middleware (auth, validation, logging)
→ Controller (req → res)
→ Service (business rules)
→ Database


Note:
| Layer          | Responsibility                  |
| -------------- | ------------------------------- |
| **Route**      | Wiring + middleware             |
| **Middleware** | Auth / permissions / validation |
| **Controller** | HTTP logic (status codes, JSON) |
| **Service**    | Business logic                  |
| **Prisma**     | Data access                     |
